# 객체 지향 프로그래밍(Object Oriented Programming)
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체로 만들고, **객체들 간의 유기적인 상호작용**을 통해 로직을 구성하는 프로그래밍 방법
- 컴퓨터로 예를 들면, **컴퓨터**를 작동시키기 위해 **여러가지 부품들( CPU, RAM, BOARD, SSD, HDD, VGA, POWER, CASE 등)이 연결되고 각자의 역할을 수행**하게 된다.
- 여기서 이 부품들 ```CPU, RAM, BOARD, SSD, HDD, VGA, POWER, CASE 등```이 **객체**에 해당하고, 부품들의 상호작용을 통해 만들어진 컴퓨터는 **객체 지향 프로그래밍**으로 만들어지게 되는 것이다.

   [객체에 대한 자세한 내용](객체.md)


### 절차 지향 프로그래밍(Procedural Programming)
- 개체를 **순차적으로 처리**하여 프로그램 전체가 유기적으로 연결되도록 하는 프로그래밍 방법
- 자동차로 예를 들면, 자동차를 만들기 위해 엔진, 차체, 핸들, 의자, 바퀴 순으로 차례대로 만들어져야 하는 것이다. 서로 분리되어도 안되고, 순서가 틀려도 안된다.
- 👍**장점**
  - 실행 속도가 빠르다.
- 👎**단점**
  - 문제를 해결하기 위해 일부분이 아닌 시스템 전체를 수리한다. 따라서 **유지 보수가 매우 까다로운 편이며, 특히 디버깅(프로그램의 문제를 찾아내어 고치는 과정)이 어렵다**.
  - 실행 순서가 정해져 있기 때문에 코드의 순서가 바뀌면 결과가 달라질 가능성이 높다. 즉, **언어의 융통성이 부족하여 생산 효율이 떨어진다.**

<br>

## 객체 지향 언어의 특징

### 클래스 + 인스턴스(객체)
- **클래스** 
  - 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 **속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것**으로 객체를 만들기 위한 메타정보라고 볼 수 있다.
- **인스턴스(객체)**
  - 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것으로 실제 프로그램에서 사용되는 데이터

### 추상화
- 객체 지향 프로그래밍에서는 **'추상화'** 라는 단어를 여러 군데 붙일 수 있다.
  - 여기서 말하는 추상화는 추상 클래스나 추상 클래스가 갖는 추상 메서드를 의미하기보다는 **클래스를 설계하는 것 자체를 의미한다.** 
  - 즉, **"공통의" 속성이나 기능을 묶어 이름을 붙이는 것**이다.

### 캡슐화
> 캡슐화의 목적 2가지
1. 코드를 재수정 없이 재활용하는 것.
2. 접근 제어자를 통한 정보 은닉

<br>

- **절차 지향 프로그래밍**에서도 라이브러리를 통해서 변수와 함수를 재활용할 수는 있었지만, 코드의 수정이 일어났을 때 영향 범위를 예상하기 어려운 문제가 있었다.
- 그러나 **객체 지향 프로그래밍**에서는 **캡슐화를 통해 객체가 외부에 노출하지 않아야할 정보 또는 기능을 접근제어자를 통해 적절히 제어 권한이 있는 객체에서만 접근하도록 할 수 있기에** 코드의 수정이 일어났을 때 책임이 있는 객체만 수정하면 되기에 영향 범위를 예측하는데 수월해졌다.
- 뿐만 아니라 **관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 객체 재활용이 원활**해졌다. 
- 객체 지향 프로그래밍에서 **기능과 특성의 모음을 ```클래스```라는 ```캡슐```에 분류해서 넣는것이 캡슐화**다.
- 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.

### 상속
- **절자 지향 프로그래밍**에서도 라이브러리를 통해서 남이 짜놓은 소스 코드를 가져와 사용할 수 있었다.
- 하지만 **내 의도에 맞게 수정하게되면 다른 라이브러리가 되어 버전에 따라 동작하지 않을 수 있고 불필요한 코드의 수정 작업을 해야한다.** 이런 문제를 해결하기 위해 상속이라는 것을 도입하였다.
- **상속**은 **부모클래스의 속성과 기능을 그대로 이어받아 사용**할 수 있게하고 **기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)** 하여 사용할 수 있게 하는 것이다.
- **다중상속은 불가하다.**

### 다형성

- **하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석**될 수 있는 것이다. 즉 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.
- 오버라이딩
  - 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.
- 오버로딩
  - 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.

![image]()

###  getter, setter 를 사용하는 이유
- ```getter```, ```setter```를 사용하면 메서드를 통해서 접근하기 때문에, **메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절**할 수 있기 때문이다.
- 예를들면, ```setter```에서 **유효범위를 넘은 정수가 들어왔을 때의 처리를 하고나서 set하거나 예외처리를 해버릴 수 있는 것**이다.
- ```getter```도 마찬가지로 굳이 예를들자면 자료에 무언가 더하거나 빼고 준다든지가 가능하다.


<br>

## 객체 지향 언어의 장점👍
**1. 재사용성**

   상속을 통해 프로그래밍시 코드의 재사용을 높일 수 있음.
   
<br>

**2. 생산성 향상**

   잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성을 향상시킬 수 있음.

<br>

**3. 자연적인 모델링**

   우리 일상생활의 모습의 구조가 객체에 자연스럽게 녹아들어 있기 때문에 생각하고 있는 것을 그대로 자연스럽게 구현할 수 있다.

<br>

**4. 유지보수의 우수성**

   프로그램 수정시 추가, 수정을 하더라도 캡슐화를 통해 주변 영향이 적기때문에 유지보수가 쉬워서 매우 경제적이라할 수 있다.

<br>

## 객체 지향 언어의 단점👎

**1. 개발속도가 느린점**

   객체가 처리하려는 것에 대한 정확한 이해가 필요하기에 설계단계부터 많은 시간이 소모 된다.

<br>

**2. 실행속도가 느린점**

   객체지향언어는 대체적으로 실행속도가 느리다.
   
<br>   
   
**3. 코딩난이도 상승**

   다중 상속이 지원되는 C++ 같은 경우에 너무 복잡해져 코딩의 난이도가 상승할 수 있다.
   
   
   
<br>
<br>

#### 참고
https://jeong-pro.tistory.com/95

https://radait.tistory.com/4
   
